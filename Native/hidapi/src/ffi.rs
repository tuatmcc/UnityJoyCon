/* automatically generated by rust-bindgen 0.72.1 */

pub const HID_API_VERSION_MAJOR: u32 = 0;
pub const HID_API_VERSION_MINOR: u32 = 16;
pub const HID_API_VERSION_PATCH: u32 = 0;
pub const HID_API_MAX_REPORT_DESCRIPTOR_SIZE: u32 = 4096;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type wchar_t = __darwin_wchar_t;
#[doc = " A structure to hold the version numbers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hid_api_version {
    #[doc = "< major version number"]
    pub major: ::std::os::raw::c_int,
    #[doc = "< minor version number"]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< patch version number"]
    pub patch: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hid_api_version"][::std::mem::size_of::<hid_api_version>() - 12usize];
    ["Alignment of hid_api_version"][::std::mem::align_of::<hid_api_version>() - 4usize];
    ["Offset of field: hid_api_version::major"]
        [::std::mem::offset_of!(hid_api_version, major) - 0usize];
    ["Offset of field: hid_api_version::minor"]
        [::std::mem::offset_of!(hid_api_version, minor) - 4usize];
    ["Offset of field: hid_api_version::patch"]
        [::std::mem::offset_of!(hid_api_version, patch) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hid_device_ {
    _unused: [u8; 0],
}
pub type hid_device = hid_device_;
#[doc = " Unknown bus type"]
pub const hid_bus_type_HID_API_BUS_UNKNOWN: hid_bus_type = 0;
#[doc = " USB bus\nSpecifications:\nhttps://usb.org/hid"]
pub const hid_bus_type_HID_API_BUS_USB: hid_bus_type = 1;
#[doc = " Bluetooth or Bluetooth LE bus\nSpecifications:\nhttps://www.bluetooth.com/specifications/specs/human-interface-device-profile-1-1-1/\nhttps://www.bluetooth.com/specifications/specs/hid-service-1-0/\nhttps://www.bluetooth.com/specifications/specs/hid-over-gatt-profile-1-0/"]
pub const hid_bus_type_HID_API_BUS_BLUETOOTH: hid_bus_type = 2;
#[doc = " I2C bus\nSpecifications:\nhttps://docs.microsoft.com/previous-versions/windows/hardware/design/dn642101(v=vs.85)"]
pub const hid_bus_type_HID_API_BUS_I2C: hid_bus_type = 3;
#[doc = " SPI bus\nSpecifications:\nhttps://www.microsoft.com/download/details.aspx?id=103325"]
pub const hid_bus_type_HID_API_BUS_SPI: hid_bus_type = 4;
#[doc = " Virtual device\nE.g.: https://elixir.bootlin.com/linux/v4.0/source/include/uapi/linux/input.h#L955\n\nSince version 0.16.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 16, 0)"]
pub const hid_bus_type_HID_API_BUS_VIRTUAL: hid_bus_type = 5;
#[doc = " @brief HID underlying bus types.\n\n@ingroup API"]
pub type hid_bus_type = ::std::os::raw::c_uint;
#[doc = " hidapi info structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hid_device_info {
    #[doc = " Platform-specific device path"]
    pub path: *mut ::std::os::raw::c_char,
    #[doc = " Device Vendor ID"]
    pub vendor_id: ::std::os::raw::c_ushort,
    #[doc = " Device Product ID"]
    pub product_id: ::std::os::raw::c_ushort,
    #[doc = " Serial Number"]
    pub serial_number: *mut wchar_t,
    #[doc = " Device Release Number in binary-coded decimal,\nalso known as Device Version Number"]
    pub release_number: ::std::os::raw::c_ushort,
    #[doc = " Manufacturer String"]
    pub manufacturer_string: *mut wchar_t,
    #[doc = " Product string"]
    pub product_string: *mut wchar_t,
    #[doc = " Usage Page for this Device/Interface\n(Windows/Mac/hidraw only)"]
    pub usage_page: ::std::os::raw::c_ushort,
    #[doc = " Usage for this Device/Interface\n(Windows/Mac/hidraw only)"]
    pub usage: ::std::os::raw::c_ushort,
    #[doc = " The USB interface which this logical device\nrepresents.\n\nValid only if the device is a USB HID device.\nSet to -1 in all other cases."]
    pub interface_number: ::std::os::raw::c_int,
    #[doc = " Pointer to the next device"]
    pub next: *mut hid_device_info,
    #[doc = " Underlying bus type\nSince version 0.13.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 13, 0)"]
    pub bus_type: hid_bus_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hid_device_info"][::std::mem::size_of::<hid_device_info>() - 72usize];
    ["Alignment of hid_device_info"][::std::mem::align_of::<hid_device_info>() - 8usize];
    ["Offset of field: hid_device_info::path"]
        [::std::mem::offset_of!(hid_device_info, path) - 0usize];
    ["Offset of field: hid_device_info::vendor_id"]
        [::std::mem::offset_of!(hid_device_info, vendor_id) - 8usize];
    ["Offset of field: hid_device_info::product_id"]
        [::std::mem::offset_of!(hid_device_info, product_id) - 10usize];
    ["Offset of field: hid_device_info::serial_number"]
        [::std::mem::offset_of!(hid_device_info, serial_number) - 16usize];
    ["Offset of field: hid_device_info::release_number"]
        [::std::mem::offset_of!(hid_device_info, release_number) - 24usize];
    ["Offset of field: hid_device_info::manufacturer_string"]
        [::std::mem::offset_of!(hid_device_info, manufacturer_string) - 32usize];
    ["Offset of field: hid_device_info::product_string"]
        [::std::mem::offset_of!(hid_device_info, product_string) - 40usize];
    ["Offset of field: hid_device_info::usage_page"]
        [::std::mem::offset_of!(hid_device_info, usage_page) - 48usize];
    ["Offset of field: hid_device_info::usage"]
        [::std::mem::offset_of!(hid_device_info, usage) - 50usize];
    ["Offset of field: hid_device_info::interface_number"]
        [::std::mem::offset_of!(hid_device_info, interface_number) - 52usize];
    ["Offset of field: hid_device_info::next"]
        [::std::mem::offset_of!(hid_device_info, next) - 56usize];
    ["Offset of field: hid_device_info::bus_type"]
        [::std::mem::offset_of!(hid_device_info, bus_type) - 64usize];
};
impl Default for hid_device_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " @brief Initialize the HIDAPI library.\n\nThis function initializes the HIDAPI library. Calling it is not\nstrictly necessary, as it will be called automatically by\nhid_enumerate() and any of the hid_open_*() functions if it is\nneeded.  This function should be called at the beginning of\nexecution however, if there is a chance of HIDAPI handles\nbeing opened by different threads simultaneously.\n\n@ingroup API\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(NULL) to get the failure reason."]
    pub fn hid_init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Finalize the HIDAPI library.\n\nThis function frees all of the static data associated with\nHIDAPI. It should be called at the end of execution to avoid\nmemory leaks.\n\n@ingroup API\n\n@returns\nThis function returns 0 on success and -1 on error."]
    pub fn hid_exit() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Enumerate the HID Devices.\n\nThis function returns a linked list of all the HID devices\nattached to the system which match vendor_id and product_id.\nIf @p vendor_id is set to 0 then any vendor matches.\nIf @p product_id is set to 0 then any product matches.\nIf @p vendor_id and @p product_id are both set to 0, then\nall HID devices will be returned.\n\n@ingroup API\n@param vendor_id The Vendor ID (VID) of the types of device\nto open.\n@param product_id The Product ID (PID) of the types of\ndevice to open.\n\n@returns\nThis function returns a pointer to a linked list of type\nstruct #hid_device_info, containing information about the HID devices\nattached to the system,\nor NULL in the case of failure or if no HID devices present in the system.\nCall hid_error(NULL) to get the failure reason.\n\n@note The returned value by this function must to be freed by calling hid_free_enumeration(),\nwhen not needed anymore."]
    pub fn hid_enumerate(
        vendor_id: ::std::os::raw::c_ushort,
        product_id: ::std::os::raw::c_ushort,
    ) -> *mut hid_device_info;
}
unsafe extern "C" {
    #[doc = " @brief Free an enumeration Linked List\n\nThis function frees a linked list created by hid_enumerate().\n\n@ingroup API\n@param devs Pointer to a list of struct_device returned from\nhid_enumerate()."]
    pub fn hid_free_enumeration(devs: *mut hid_device_info);
}
unsafe extern "C" {
    #[doc = " @brief Open a HID device using a Vendor ID (VID), Product ID\n(PID) and optionally a serial number.\n\nIf @p serial_number is NULL, the first device with the\nspecified VID and PID is opened.\n\n@ingroup API\n@param vendor_id The Vendor ID (VID) of the device to open.\n@param product_id The Product ID (PID) of the device to open.\n@param serial_number The Serial Number of the device to open\n(Optionally NULL).\n\n@returns\nThis function returns a pointer to a #hid_device object on\nsuccess or NULL on failure.\nCall hid_error(NULL) to get the failure reason.\n\n@note The returned object must be freed by calling hid_close(),\nwhen not needed anymore."]
    pub fn hid_open(
        vendor_id: ::std::os::raw::c_ushort,
        product_id: ::std::os::raw::c_ushort,
        serial_number: *const wchar_t,
    ) -> *mut hid_device;
}
unsafe extern "C" {
    #[doc = " @brief Open a HID device by its path name.\n\nThe path name be determined by calling hid_enumerate(), or a\nplatform-specific path name can be used (eg: /dev/hidraw0 on\nLinux).\n\n@ingroup API\n@param path The path name of the device to open\n\n@returns\nThis function returns a pointer to a #hid_device object on\nsuccess or NULL on failure.\nCall hid_error(NULL) to get the failure reason.\n\n@note The returned object must be freed by calling hid_close(),\nwhen not needed anymore."]
    pub fn hid_open_path(path: *const ::std::os::raw::c_char) -> *mut hid_device;
}
unsafe extern "C" {
    #[doc = " @brief Write an Output report to a HID device.\n\nThe first byte of @p data[] must contain the Report ID. For\ndevices which only support a single report, this must be set\nto 0x0. The remaining bytes contain the report data. Since\nthe Report ID is mandatory, calls to hid_write() will always\ncontain one more byte than the report contains. For example,\nif a hid report is 16 bytes long, 17 bytes must be passed to\nhid_write(), the Report ID (or 0x0, for devices with a\nsingle report), followed by the report data (16 bytes). In\nthis example, the length passed in would be 17.\n\nhid_write() will send the data on the first interrupt OUT\nendpoint, if one exists. If it does not the behaviour is as\n@ref hid_send_output_report\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data The data to send, including the report number as\nthe first byte.\n@param length The length in bytes of the data to send.\n\n@returns\nThis function returns the actual number of bytes written and\n-1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_write(
        dev: *mut hid_device,
        data: *const ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Read an Input report from a HID device with timeout.\n\nInput reports are returned\nto the host through the INTERRUPT IN endpoint. The first byte will\ncontain the Report number if the device uses numbered reports.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data A buffer to put the read data into.\n@param length The number of bytes to read. For devices with\nmultiple reports, make sure to read an extra byte for\nthe report number.\n@param milliseconds timeout in milliseconds or -1 for blocking wait.\n\n@returns\nThis function returns the actual number of bytes read and\n-1 on error.\nCall hid_read_error(dev) to get the failure reason.\nIf no packet was available to be read within\nthe timeout period, this function returns 0.\n\n@note This function doesn't change the buffer returned by the hid_error(dev)."]
    pub fn hid_read_timeout(
        dev: *mut hid_device,
        data: *mut ::std::os::raw::c_uchar,
        length: usize,
        milliseconds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Read an Input report from a HID device.\n\nInput reports are returned\nto the host through the INTERRUPT IN endpoint. The first byte will\ncontain the Report number if the device uses numbered reports.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data A buffer to put the read data into.\n@param length The number of bytes to read. For devices with\nmultiple reports, make sure to read an extra byte for\nthe report number.\n\n@returns\nThis function returns the actual number of bytes read and\n-1 on error.\nCall hid_read_error(dev) to get the failure reason.\nIf no packet was available to be read and\nthe handle is in non-blocking mode, this function returns 0.\n\n@note This function doesn't change the buffer returned by the hid_error(dev)."]
    pub fn hid_read(
        dev: *mut hid_device,
        data: *mut ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a string describing the last error which occurred during hid_read/hid_read_timeout.\n\nSince version 0.15.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 15, 0)\n\nThis function is intended for logging/debugging purposes.\n\nThis function guarantees to never return NULL for a valid @ref dev.\nIf there was no error in the last call to hid_read/hid_read_error -\nthe returned string clearly indicates that.\n\nStrings returned from hid_read_error() must not be freed by the user,\ni.e. owned by HIDAPI library.\nDevice-specific error string may remain allocated at most until hid_close() is called.\n\n@ingroup API\n@param dev A device handle. Shall never be NULL.\n\n@returns\nA string describing the hid_read/hid_read_timeout error (if any)."]
    pub fn hid_read_error(dev: *mut hid_device) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the device handle to be non-blocking.\n\nIn non-blocking mode calls to hid_read() will return\nimmediately with a value of 0 if there is no data to be\nread. In blocking mode, hid_read() will wait (block) until\nthere is data to read before returning.\n\nNonblocking can be turned on and off at any time.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param nonblock enable or not the nonblocking reads\n- 1 to enable nonblocking\n- 0 to disable nonblocking.\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_set_nonblocking(
        dev: *mut hid_device,
        nonblock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Send a Feature report to the device.\n\nFeature reports are sent over the Control endpoint as a\nSet_Report transfer.  The first byte of @p data[] must\ncontain the Report ID. For devices which only support a\nsingle report, this must be set to 0x0. The remaining bytes\ncontain the report data. Since the Report ID is mandatory,\ncalls to hid_send_feature_report() will always contain one\nmore byte than the report contains. For example, if a hid\nreport is 16 bytes long, 17 bytes must be passed to\nhid_send_feature_report(): the Report ID (or 0x0, for\ndevices which do not use numbered reports), followed by the\nreport data (16 bytes). In this example, the length passed\nin would be 17.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data The data to send, including the report number as\nthe first byte.\n@param length The length in bytes of the data to send, including\nthe report number.\n\n@returns\nThis function returns the actual number of bytes written and\n-1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_send_feature_report(
        dev: *mut hid_device,
        data: *const ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a feature report from a HID device.\n\nSet the first byte of @p data[] to the Report ID of the\nreport to be read.  Make sure to allow space for this\nextra byte in @p data[]. Upon return, the first byte will\nstill contain the Report ID, and the report data will\nstart in data[1].\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data A buffer to put the read data into, including\nthe Report ID. Set the first byte of @p data[] to the\nReport ID of the report to be read, or set it to zero\nif your device does not use numbered reports.\n@param length The number of bytes to read, including an\nextra byte for the report ID. The buffer can be longer\nthan the actual report.\n\n@returns\nThis function returns the number of bytes read plus\none for the report ID (which is still in the first\nbyte), or -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_feature_report(
        dev: *mut hid_device,
        data: *mut ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Send a Output report to the device.\n\nSince version 0.15.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 15, 0)\n\nOutput reports are sent over the Control endpoint as a\nSet_Report transfer.  The first byte of @p data[] must\ncontain the Report ID. For devices which only support a\nsingle report, this must be set to 0x0. The remaining bytes\ncontain the report data. Since the Report ID is mandatory,\ncalls to hid_send_output_report() will always contain one\nmore byte than the report contains. For example, if a hid\nreport is 16 bytes long, 17 bytes must be passed to\nhid_send_output_report(): the Report ID (or 0x0, for\ndevices which do not use numbered reports), followed by the\nreport data (16 bytes). In this example, the length passed\nin would be 17.\n\nThis function sets the return value of hid_error().\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data The data to send, including the report number as\nthe first byte.\n@param length The length in bytes of the data to send, including\nthe report number.\n\n@returns\nThis function returns the actual number of bytes written and\n-1 on error.\n\n@see @ref hid_write"]
    pub fn hid_send_output_report(
        dev: *mut hid_device,
        data: *const ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a input report from a HID device.\n\nSince version 0.10.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 10, 0)\n\nSet the first byte of @p data[] to the Report ID of the\nreport to be read. Make sure to allow space for this\nextra byte in @p data[]. Upon return, the first byte will\nstill contain the Report ID, and the report data will\nstart in data[1].\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param data A buffer to put the read data into, including\nthe Report ID. Set the first byte of @p data[] to the\nReport ID of the report to be read, or set it to zero\nif your device does not use numbered reports.\n@param length The number of bytes to read, including an\nextra byte for the report ID. The buffer can be longer\nthan the actual report.\n\n@returns\nThis function returns the number of bytes read plus\none for the report ID (which is still in the first\nbyte), or -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_input_report(
        dev: *mut hid_device,
        data: *mut ::std::os::raw::c_uchar,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Close a HID device.\n\n@ingroup API\n@param dev A device handle returned from hid_open()."]
    pub fn hid_close(dev: *mut hid_device);
}
unsafe extern "C" {
    #[doc = " @brief Get The Manufacturer String from a HID device.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param string A wide string buffer to put the data into.\n@param maxlen The length of the buffer in multiples of wchar_t.\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_manufacturer_string(
        dev: *mut hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get The Product String from a HID device.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param string A wide string buffer to put the data into.\n@param maxlen The length of the buffer in multiples of wchar_t.\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_product_string(
        dev: *mut hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get The Serial Number String from a HID device.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param string A wide string buffer to put the data into.\n@param maxlen The length of the buffer in multiples of wchar_t.\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_serial_number_string(
        dev: *mut hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get The struct #hid_device_info from a HID device.\n\nSince version 0.13.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 13, 0)\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n\n@returns\nThis function returns a pointer to the struct #hid_device_info\nfor this hid_device, or NULL in the case of failure.\nCall hid_error(dev) to get the failure reason.\nThis struct is valid until the device is closed with hid_close().\n\n@note The returned object is owned by the @p dev, and SHOULD NOT be freed by the user."]
    pub fn hid_get_device_info(dev: *mut hid_device) -> *mut hid_device_info;
}
unsafe extern "C" {
    #[doc = " @brief Get a string from a HID device, based on its string index.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param string_index The index of the string to get.\n@param string A wide string buffer to put the data into.\n@param maxlen The length of the buffer in multiples of wchar_t.\n\n@returns\nThis function returns 0 on success and -1 on error.\nCall hid_error(dev) to get the failure reason."]
    pub fn hid_get_indexed_string(
        dev: *mut hid_device,
        string_index: ::std::os::raw::c_int,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a report descriptor from a HID device.\n\nSince version 0.14.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 14, 0)\n\nUser has to provide a preallocated buffer where descriptor will be copied to.\nThe recommended size for preallocated buffer is @ref HID_API_MAX_REPORT_DESCRIPTOR_SIZE bytes.\n\n@ingroup API\n@param dev A device handle returned from hid_open().\n@param buf The buffer to copy descriptor into.\n@param buf_size The size of the buffer in bytes.\n\n@returns\nThis function returns non-negative number of bytes actually copied, or -1 on error."]
    pub fn hid_get_report_descriptor(
        dev: *mut hid_device,
        buf: *mut ::std::os::raw::c_uchar,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a string describing the last error which occurred.\n\nThis function is intended for logging/debugging purposes.\n\nThis function guarantees to never return NULL.\nIf there was no error in the last function call -\nthe returned string clearly indicates that.\n\nAny HIDAPI function that can explicitly indicate an execution failure\n(e.g. by an error code, or by returning NULL) - may set the error string,\nto be returned by this function.\n\nStrings returned from hid_error() must not be freed by the user,\ni.e. owned by HIDAPI library.\nDevice-specific error string may remain allocated at most until hid_close() is called.\nGlobal error string may remain allocated at most until hid_exit() is called.\n\n@ingroup API\n@param dev A device handle returned from hid_open(),\nor NULL to get the last non-device-specific error\n(e.g. for errors in hid_open() or hid_enumerate()).\n\n@returns\nA string describing the last error (if any)."]
    pub fn hid_error(dev: *mut hid_device) -> *const wchar_t;
}
unsafe extern "C" {
    #[doc = " @brief Get a runtime version of the library.\n\nThis function is thread-safe.\n\n@ingroup API\n\n@returns\nPointer to statically allocated struct, that contains version."]
    pub fn hid_version() -> *const hid_api_version;
}
unsafe extern "C" {
    #[doc = " @brief Get a runtime version string of the library.\n\nThis function is thread-safe.\n\n@ingroup API\n\n@returns\nPointer to statically allocated string, that contains version string."]
    pub fn hid_version_str() -> *const ::std::os::raw::c_char;
}
